<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[CSS之Position]]></title>
    <url>%2F2019%2F05%2F20%2FCSS%E4%B9%8BPosition%2F</url>
    <content type="text"><![CDATA[position 属性的五个值：static:默认值relative:相对定位fixed:固定位置absolute:绝对定位sticky：粘性定位** position 属性position 属性指定了元素的定位类型。position 属性的五个值：static:默认值relative:相对定位fixed:固定位置absolute:绝对定位sticky：粘性定位 HTML实例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot; /&gt;&lt;title&gt;position&lt;/title&gt;&lt;style type=&quot;text/css&quot;&gt;*&#123;margin:0;padding:0;&#125;.clearfix:before,.clearfix:after &#123;content:&quot;&quot;;display:table;&#125;.clearfix:after &#123;clear:both;overflow:hidden;&#125;.clearfix &#123;zoom:1;&#125;.mgt20&#123;margin-top:20px;&#125;.w1000&#123;width:1000px;margin:0 auto;min-height:1900px;&#125;#demo&#123; position:relative; border:1px solid #000; margin-top:50px; top:-50px; line-height:18px; &#125; .static,.fixed,.absolute,.relative&#123; width:200px; &#125; .relative&#123; position:relative; left:150px; top:-20px; background-color:#ffe4e1; &#125;.static&#123; position:static; background-color:#bbb; &#125; .fixed&#123; position:fixed; top:200px; left:50%; margin-left:-500px; background-color:#ffc0cb;&#125; .absolute&#123; position:absolute; right:10px; top:10px; background-color:#b0c4de; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;w1000&quot;&gt; &lt;div class=&quot;mgt20 clearfix&quot;&gt; &lt;div id=&quot;demo&quot; class=&quot;clearfix&quot;&gt; &lt;div class=&quot;static&quot;&gt;static: 默认值。无特殊定位，对象遵循HTML定位规则 &lt;/div&gt; &lt;div class=&quot;absolute&quot;&gt;absolute: 将对象从文档流中拖出,使用left,right,top,bottom 等属性相对于其最接近的一个最有定位设置的父对象进行绝对定位。如果不存在这样的父对象,则依据body对象。而其层叠通过z-index属性定义 &lt;/div&gt; &lt;div class=&quot;fixed&quot;&gt;fixed属性的说明：fixed总是以body为定位时的对象，总是根据浏览器的窗口来进行元素的定位，通过&quot;left&quot;、 &quot;top&quot;、 &quot;right&quot;、&quot;bottom&quot; 属性进行定位。&lt;/div&gt; &lt;div class=&quot;relative&quot;&gt;relative1:对象不可层叠，对象原来占有的位置保留,但将依据 left,right,top,bottom 等属性在正常文档流中偏移位置 &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; absolute绝对定位生成绝对定位的元素，相对于 static 定位以外的第一个父元素进行定位。 12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;定位页面&lt;/title&gt; &lt;/head&gt; &lt;style&gt; div.pos_QM&#123; position:absolute; left:100px; top:150px; width:200px; height:200px; background-color:black; color:white; text-align:center; &#125; div&#123; border:2px solid black; &#125; &lt;/style&gt; &lt;body&gt; &lt;div class=&quot;pos_QM&quot;&gt; 这是一个绝对定位的盒子 &lt;/div&gt; &lt;div&gt; 通过绝对定位,元素可以放置在页面上的任何位置,下面的黑色盒子距离页面左侧100px,距离页面顶部150px. &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 取值static该关键字指定元素使用正常的布局行为，即元素在文档常规流中当前的布局位置。此时 top, right, bottom, left 和 z-index 属性无效。relative该关键字下，元素先放置在未添加定位时的位置，再在不改变页面布局的前提下调整元素位置（因此会在此元素未添加定位时所在位置留下空白）。position:relative 对 table-*-group, table-row, table-column, table-cell, table-caption 元素无效。absolute不为元素预留空间，通过指定元素相对于最近的非 static 定位祖先元素的偏移，来确定元素位置。绝对定位的元素可以设置外边距（margins），且不会与其他边距合并。fixed不为元素预留空间，而是通过指定元素相对于屏幕视口（viewport）的位置来指定元素位置。元素的位置在屏幕滚动时不会改变。打印时，元素会出现在的每页的固定位置。fixed 属性会创建新的层叠上下文。当元素祖先的 transform 属性非 none 时，容器由视口改为该祖先。sticky盒位置根据正常流计算(这称为正常流动中的位置)，然后相对于该元素在流中的 flow root（BFC）和 containing block（最近的块级祖先元素）定位。在所有情况下（即便被定位元素为 table 时），该元素定位均不对后续元素造成影响。当元素 B 被粘性定位时，后续元素的位置仍按照 B 未定位时的位置来确定。position: sticky 对 table 元素的效果与 position: relative 相同。 常见语法1static | relative | absolute | sticky | fixed]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maven插件]]></title>
    <url>%2F2019%2F05%2F20%2FMaven%E6%8F%92%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[Maven 翻译为”专家”、”内行”，是 Apache 下的一个纯 Java 开发的开源项目。基于项目对象模型（缩写：POM）概念，Maven利用一个中央信息片断能管理一个项目的构建、报告和文档等步骤。 Maven 是一个项目管理工具，可以对 Java 项目进行构建、依赖管理。也可被用于构建和管理各种项目，例如 C#，Ruby，Scala 和其他语言编写的项目。Maven 曾是 Jakarta 项目的子项目，现为由 Apache 软件基金会主持的独立 Apache 项目。 Maven 翻译为”专家”、”内行”，是 Apache 下的一个纯 Java 开发的开源项目。基于项目对象模型（缩写：POM）概念，Maven利用一个中央信息片断能管理一个项目的构建、报告和文档等步骤。Maven 是一个项目管理工具，可以对 Java 项目进行构建、依赖管理。Maven 也可被用于构建和管理各种项目，例如 C#，Ruby，Scala 和其他语言编写的项目。Maven 曾是 Jakarta 项目的子项目，现为由 Apache 软件基金会主持的独立 Apache 项目。 Maven 插件Maven 有以下三个标准的生命周期： clean：项目清理的处理 default(或 build)：项目部署的处理 site：项目站点文档创建的处理 每个生命周期中都包含着一系列的阶段(phase)。这些 phase 就相当于 Maven 提供的统一的接口，然后这些 phase 的实现由 Maven 的插件来完成。我们在输入 mvn 命令的时候 比如 mvn clean，clean 对应的就是 Clean 生命周期中的 clean 阶段。但是 clean 的具体操作是由 maven-clean-plugin 来实现的。所以说 Maven 生命周期的每一个阶段的具体实现都是由 Maven 插件实现的。Maven 实际上是一个依赖插件执行的框架，每个任务实际上是由插件完成。Maven 插件通常被用来： ** 创建 jar 文件 创建 war 文件 编译代码文件 代码单元测试 创建工程文档 创建工程报告**插件通常提供了一个目标的集合，并且可以使用下面的语法执行： 1&lt;code&gt;mvn [plugin-name]:[goal-name]&lt;/code&gt; 例如，一个 Java 工程可以使用 maven-compiler-plugin 的 compile-goal 编译，使用以下命令： 1&lt;code&gt;mvn compiler:compile&lt;/code&gt; 插件类型1.Build plugins : 在构建时执行，并在 pom.xml 的 元素中配置。2.Reporting plugins : 在网站生成过程中执行，并在 pom.xml 的 元素中配置。 实例1234567891011121314151617181920212223242526272829303132&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;&lt;groupId&gt;com.companyname.projectgroup&lt;/groupId&gt;&lt;artifactId&gt;project&lt;/artifactId&gt;&lt;version&gt;1.0&lt;/version&gt;&lt;build&gt;&lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-antrun-plugin&lt;/artifactId&gt; &lt;version&gt;1.1&lt;/version&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;id.clean&lt;/id&gt; &lt;phase&gt;clean&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;run&lt;/goal&gt; &lt;/goals&gt; &lt;configuration&gt; &lt;tasks&gt; &lt;echo&gt;clean phase&lt;/echo&gt; &lt;/tasks&gt; &lt;/configuration&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt;&lt;/plugins&gt;&lt;/build&gt;&lt;/project&gt; 参考：菜鸟教程]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++动态内存]]></title>
    <url>%2F2019%2F05%2F17%2FC-%E5%86%85%E5%AD%98%2F</url>
    <content type="text"><![CDATA[了解动态内存在 C++ 中是如何工作的是成为一名合格的 C++ 程序员必不可少的。 了解动态内存在 C++ 中是如何工作的是成为一名合格的 C++ 程序员必不可少的。C++ 程序中的内存分为两个部分：栈：在函数内部声明的所有变量都将占用栈内存。堆：这是程序中未使用的内存，在程序运行时可用于动态分配内存。 很多时候，您无法提前预知需要多少内存来存储某个定义变量中的特定信息，所需内存的大小需要在运行时才能确定。在 C++ 中，您可以使用特殊的运算符为给定类型的变量在运行时分配堆内的内存，这会返回所分配的空间地址。这种运算符即 new 运算符。如果您不再需要动态分配的内存空间，可以使用 delete 运算符，删除之前由 new 运算符分配的内存。 new 和 delete 运算符下面是使用 new 运算符来为任意的数据类型动态分配内存的通用语法： 1new data-type; 在这里，data-type 可以是包括数组在内的任意内置的数据类型，也可以是包括类或结构在内的用户自定义的任何数据类型。让我们先来看下内置的数据类型。例如，我们可以定义一个指向 double 类型的指针，然后请求内存，该内存在执行时被分配。我们可以按照下面的语句使用 new 运算符来完成这点： 12double* pvalue = NULL; // 初始化为 null 的指针pvalue = new double; // 为变量请求内存 如果自由存储区已被用完，可能无法成功分配内存。所以建议检查 new 运算符是否返回 NULL 指针，并采取以下适当的操作： 12345678double* pvalue = NULL;if( !(pvalue = new double ))&#123; cout &lt;&lt; &quot;Error: out of memory.&quot; &lt;&lt;endl; exit(1); &#125; malloc() 函数在 C 语言中就出现了，在 C++ 中仍然存在，但建议尽量不要使用 malloc() 函数。new 与 malloc() 函数相比，其主要的优点是，new 不只是分配了内存，它还创建了对象。在任何时候，当您觉得某个已经动态分配内存的变量不再需要使用时，您可以使用 delete 操作符释放它所占用的内存，如下所示： 1delete pvalue; // 释放 pvalue 所指向的内存 下面的实例中使用了上面的概念，演示了如何使用 new 和 delete 运算符： 123456789101112131415#include &lt;iostream&gt;using namespace std; int main ()&#123; double* pvalue = NULL; // 初始化为 null 的指针 pvalue = new double; // 为变量请求内存 *pvalue = 29494.99; // 在分配的地址存储值 cout &lt;&lt; &quot;Value of pvalue : &quot; &lt;&lt; *pvalue &lt;&lt; endl; delete pvalue; // 释放内存 return 0; 数组的动态内存分配假设我们要为一个字符数组（一个有 20 个字符的字符串）分配内存，我们可以使用上面实例中的语法来为数组动态地分配内存，如下所示： 12char* pvalue = NULL; // 初始化为 null 的指针pvalue = new char[20]; // 为变量请求内存 要删除我们刚才创建的数组，语句如下： 1delete [] pvalue; // 删除 pvalue 所指向的数组 一维数组12345// 动态分配,数组长度为 mint *array=new int [m]； //释放内存delete [] array; 二维数组123456789101112131415int **array// 假定数组第一维长度为 m， 第二维长度为 n// 动态分配空间array = new int *[m];for( int i=0; i&lt;m; i++ )&#123; array[i] = new int [n] ;&#125;//释放for( int i=0; i&lt;m; i++ )&#123; delete [] arrar[i];&#125;delete [] array; 二维数组实例测试：12345678910111213141516171819202122232425262728293031323334#include &lt;iostream&gt;using namespace std; int main()&#123; int **p; int i,j; //p[4][8] //开始分配4行8列的二维数据 p = new int *[4]; for(i=0;i&lt;4;i++)&#123; p[i]=new int [8]; &#125; for(i=0; i&lt;4; i++)&#123; for(j=0; j&lt;8; j++)&#123; p[i][j] = j*i; &#125; &#125; //打印数据 for(i=0; i&lt;4; i++)&#123; for(j=0; j&lt;8; j++) &#123; if(j==0) cout&lt;&lt;endl; cout&lt;&lt;p[i][j]&lt;&lt;&quot;\t&quot;; &#125; &#125; //开始释放申请的堆 for(i=0; i&lt;4; i++)&#123; delete [] p[i]; &#125; delete [] p; return 0;&#125; 三维数组12345678910111213141516171819202122int ***array;// 假定数组第一维为 m， 第二维为 n， 第三维为h// 动态分配空间array = new int **[m];for( int i=0; i&lt;m; i++ )&#123; array[i] = new int *[n]; for( int j=0; j&lt;n; j++ ) &#123; array[i][j] = new int [h]; &#125;&#125;//释放for( int i=0; i&lt;m; i++ )&#123; for( int j=0; j&lt;n; j++ ) &#123; delete array[i][j]; &#125; delete array[i];&#125;delete [] array; 三维数组测试实例：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;iostream&gt;using namespace std; int main()&#123; int i,j,k; // p[2][3][4] int ***p; p = new int **[2]; for(i=0; i&lt;2; i++) &#123; p[i]=new int *[3]; for(j=0; j&lt;3; j++) p[i][j]=new int[4]; &#125; //输出 p[i][j][k] 三维数据 for(i=0; i&lt;2; i++) &#123; for(j=0; j&lt;3; j++) &#123; for(k=0;k&lt;4;k++) &#123; p[i][j][k]=i+j+k; cout&lt;&lt;p[i][j][k]&lt;&lt;&quot; &quot;; &#125; cout&lt;&lt;endl; &#125; cout&lt;&lt;endl; &#125; // 释放内存 for(i=0; i&lt;2; i++) &#123; for(j=0; j&lt;3; j++) &#123; delete [] p[i][j]; &#125; &#125; for(i=0; i&lt;2; i++) &#123; delete [] p[i]; &#125; delete [] p; return 0;&#125; 对象的动态内存分配对象与简单的数据类型没有什么不同。例如，请看下面的代码，我们将使用一个对象数组来理清这一概念： 12345678910111213141516171819202122#include &lt;iostream&gt;using namespace std; class Box&#123; public: Box() &#123; cout &lt;&lt; &quot;调用构造函数！&quot; &lt;&lt;endl; &#125; ~Box() &#123; cout &lt;&lt; &quot;调用析构函数！&quot; &lt;&lt;endl; &#125;&#125;; int main( )&#123; Box* myBoxArray = new Box[4]; delete [] myBoxArray; // 删除数组 return 0;&#125;]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F05%2F13%2Fhello-world%2F</url>
    <content type="text"><![CDATA[第一篇博客搭建 Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
